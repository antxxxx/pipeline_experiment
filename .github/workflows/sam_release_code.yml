name: release package workflow

on:
  workflow_call:
    inputs:
      STACK_NAME:
        required: true
        type: string
      ARTIFACT_BUCKET_PREFIX:
          required: true
          type: string
      TARGET_ENVIRONMENT:
        required: true
        type: string
      VERSION_NUMBER:
        required: true
        type: string
    secrets:
      CLOUD_FORMATION_DEPLOY_ROLE:
        required: true

jobs:
  release_package:
    runs-on: ubuntu-latest
    environment:  ${{ inputs.TARGET_ENVIRONMENT }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: show environment
        run: |
          echo "TEPMLATE_FILE: ${{ inputs.TEPMLATE_FILE }}"
          echo "STACK_NAME: ${{ inputs.STACK_NAME }}"
          echo "CLOUD_FORMATION_DEPLOY_ROLE: ${{ inputs.CLOUD_FORMATION_DEPLOY_ROLE }}"
          echo "TARGET_ENVIRONMENT: ${{ inputs.TARGET_ENVIRONMENT }}"
          echo "VERSION_NUMBER: ${{ inputs.VERSION_NUMBER }}"

  fix_deployments:
    runs-on: ubuntu-latest
    needs: release_package
    steps:
      - name: Delete Previous deployments
        uses: actions/github-script@v6
        with:
          script: |
            const refForTagging = '${{ inputs.VERSION_NUMBER }}'.startsWith('PR-') ? '${{ github.event.pull_request.head.sha }}' : '${{ inputs.VERSION_NUMBER }}'
            const refToDelete = '${{ inputs.VERSION_NUMBER }}'.startsWith('PR-') ? '${{ github.event.pull_request.head.sha }}' : context.sha
            // get current deployments for the current tag and environment
            const deployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: refToDelete,
              environment: '${{ inputs.TARGET_ENVIRONMENT }}'
            });
            await Promise.all(
              deployments.data.map(async (deployment) => {
                // set current deployment to inactive so it can be deleted
                console.log(`setting deployment_id ${deployment.id} to inactive`)
                await github.rest.repos.createDeploymentStatus({ 
                  owner: context.repo.owner, 
                  repo: context.repo.repo, 
                  deployment_id: deployment.id, 
                  state: 'inactive' 
                });
                // delete the deployment
                console.log(`deleting deployment_id ${deployment.id}`)
                return github.rest.repos.deleteDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id
                });
              })
            );
            // create the new deployment
            console.log(`creating deployment for ref ${refForTagging} with environment ${{ inputs.TARGET_ENVIRONMENT }} and description ${{ inputs.VERSION_NUMBER }}`)
            const deployment = await github.rest.repos.createDeployment({ 
              owner: context.repo.owner, 
              repo: context.repo.repo, 
              ref: refForTagging,
              auto_merge: false,
              required_contexts: [],
              environment: '${{ inputs.TARGET_ENVIRONMENT }}',
              description: '${{ inputs.VERSION_NUMBER }}'
            });
            // set deployment to success
            console.log(`updating status for deployment id ${deployment.data.id}`)
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner, 
              repo: context.repo.repo, 
              deployment_id: deployment.data.id,
              description: '${{ inputs.VERSION_NUMBER }}',
              state: 'success'
            });
